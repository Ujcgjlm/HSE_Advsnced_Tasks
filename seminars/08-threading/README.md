# Введение в многопоточность
### Вспоминаем лекцию
Освежим немного базовые примитивы в памяти.
Позапускаем потоки: [01-hello-threads.cpp](01-hello-threads.cpp).
Посмотрим на race в cout: [hello-hello-threads-hello-threads-threads](02-racy-cout.cpp)

### Применяем
Смотрим, как все ускоряется.
Посчитаем сумму квадратных корней первых 1e9 натуральных чисел: [03-sqrts.cpp](03-sqrts.cpp).
```
$ ./03-sqrts $((1000 ** 3)) 6
num_threads: 6, limit: 1000000000
sum: 2.10819e+13, elapsed: {cpu_time: 3.15542s, wall_time: 0.558082s, ratio: 5.65404x}
```

Насколько дорого запускать потоки?
Решим глупым образом предыдущую задачу: запустим по потоку на каждое число.
Рядом посмотрим на аналогичное решение с одним потоком и потокобезопасной очередью (это черный ящик, про нее достаточно объяснить интерфейс, кондвары на следующем семинаре): [04-launch.cpp](04-launch.cpp).
Видно, что решение с очередью быстрее на порядки.
В чем проблема?
Посмотрим на программу изнутри через `perf trace` / `strace -T`.
Видно, что запуск каждого потока --- числа порядка сотен микросекунд.
Вывод: потоки запускаем редко, обычно --- на старте приложения делаем несколько тредпулов.

### std::async
TLDR: не используем.

Решим нашу задачу, запустив вычисления корней через `std::async`.
Считается подозрительно долго; посмотрим в `strace`.
`std::async` в `libc++` / `libstdc++` запускает по потоку на каждый вызов, как мы делали только что. В MSVC набор глобальных тредпулов, что в целом тоже неудобно.
По интерфейсу можно было бы предположить, что стандартная библиотека делает что-то умное под капотом, но нет.

### False sharing
Пусть есть набор потоков, каждый из которых регулярно обновляет некоторый счетчик.
Позапускаем: [06-false-sharing.cpp](06-false-sharing.cpp)
Видно, что если добавить выравнивание на 64, то все ускоряется в десятки раз. В чем проблема?
Можно посмотреть в perf report & perf record, ассемблер уже щупали.
False sharing: пишем и читаем кеш-линиями, запись в кеш-линию инвалидирует ее на остальных ядрах.

Как избавиться от хардкода 64? Никак:( Есть [std::hardware_destructive_interference_size](https://en.cppreference.com/w/cpp/thread/hardware_destructive_interference_size), но он никогда не будет реализован в стдлибах из-за требований на сохранения ABI: после фиксации числа один раз мы не сможем его сломать. Но сейчас на популярных архитектурах кеш-линии по 64 байта.

Важно, что в примере со счетчиками не обязательно atomic; он используется только чтоб гарантировать запись.
Аналогичное поведение можно наблюдать и с обычными переменными.

Какой вывод? Потоки должны как можно меньше писать в общую память.
