# Продвинутые потоки

### Futex
TODO

### Lock-free
CAS, lock-free-stack, ABA, RCU, hazard-ptr?

### Future / Promise
Рано или поздно вам захочется передавать данные между потоками.
Например, запустить задачу в потоке, а по завершению задачи выполнить какой-то код.
Известных нам примитивов недостаточно для удобной разработки; на помощь приходят
`Future / Promise`. Это некоторый канал для передачи значения: с одной стороны (Promise) значение
можно записать, с другой (Future) --- дождаться / подписаться. Оказывается довольно удобно,
особенно если есть богатые возможности для комбинирования фьючей.
К сожалению, стандартные фьючи не такие, их никто не использует.

Предлагается написать кода из executors: Future / Promise, Subscribe, пачку комбинаторов (Join, WaitAny). Не слишком шаблонно, 100 -- 200 строк.

https://github.com/facebook/folly/blob/main/folly/docs/Futures.md

### Nanofibers (опционально)
_NB: основная цель здесь -- дать прочувствовать семантику файберов, почему и когда они лучше, чем потоки, а почему и когда хуже; нужно больше слов, в код смотреть скорее не надо даже._

Попробуем посмотреть на максимально простую библиотеку _файберов_ (aka goroutines, green threads, иногда корутины) --- легких потоков в пространстве пользователя с кооперативной многозадачностью.
На файберах работают современные модные асинхронные фреймворки и языки; в первую очередь Go, где
весь язык построен вокруг них.

Что значит страшное определение выше?
1. В пространстве пользователя: выбор потока для запуска и переключение между потоками происходит
без переключения в ядро; переключение в ядро --- дорогая операция.
1. В одно и то же время может выполняться не больше потоков, чем у вас есть ядер в процессоре.
Как тогда работает система? Она очень часто (типичные цифры --- единицы миллисекунд)
переключает потоки выполнения, при этом может создаться
иллюзия, что все работает одновременно. Как следствие, в уже относительно привычном
вам многопоточном программировании система могла снять ваш поток с выполнения в любой момент.
При этом даже понять, что это произошло, довольно сложно.
Такой механизм называется _вытесняющая многозадачность_.
Мы же реализуем _кооперативную многозадачность_: здесь потоки не пытаются бороться за ресурс процессора, а отдают добровольно выполнение другим потокам, когда это нужно. Например, когда файбер блокирует
мьютекс, он отдает выполнение другим файберам.
1. Файберы легкие: создание --- единицы микросекунд, переключение между потоками --- пара десятков
инструкций. Это позволяет эффективно управлять большим количество файберов (сотни тысяч), и
создавать файберы на "каждый чих": например, на каждый запрос в сервер.

Для простоты сегодня nanofibers будут полностью однопоточными; более реалистичные файберы вы увдите
у Ромы Липовского. Покажем, как использовать файберы:
```cpp
nanofibers::Scheduler scheduler;

// Run main routine
scheduler.Run([&] {
    nanofibers::Spawn([] {
        for (int i = 0; i < 3; ++i) {
            printf("{Fiber #1} Ping\n");
            scheduler.Yield();
        }
    });
    nanofibers::Spawn([] {
        for (int i = 0; i < 3; ++i) {
            printf("{Fiber #2} Pong\n");
            scheduler.Yield();
        }
    });
});

// Output:
// {Fiber #1} Ping
// {Fiber #2} Pong
// {Fiber #1} Ping
// {Fiber #2} Pong
// {Fiber #1} Ping
// {Fiber #2} Pong
```

##### АКОС на максималках (для самых любознательных)

Как это работает? Ключевое место --- использование `Yield()` в коде.
`Yield()` отпускает выполнение текущего файбера и переключается на следующий готовый.

##### Захват и переключение контекста
Что есть состояние потока? Это, на самом деле, состояние процессора и стек потока; остальные
данные для него. Состояние процессора в нашем случае почти полностью представимо просто набором
general purpose регистров, так что его можно целиком сохранить в понятную структуру.

Вся магия по переключению между файберами происходит в [context.S](01-nanofibers-simple/context.S).
Данные операции не выразимы через C / C++, но ассемблер совсем простой.
Основная операция --- переключение между двумя контекстами:
```cpp
Context from, to;
if (SaveContext(&from)) {
    JumpContext(&to);
} else {
    // continue
}
```
Семантика хитрая: SaveContext возвращает управление два раза. Первый раз --- сразу после вызова,
а второй --- когда на `from` позовут JumpContext. Например, для такого кода
```cpp
Context ctx;
if (SaveContext(&ctx)) {
    printf("First");
    JumpContext(&ctx);
} else {
    printf("Second");
}
```
Вывод будет
```
First
Second
```

##### Стек
Осталось разобраться со стеками.
На самом деле, стек --- это просто регион памяти, их можно выделять руками.
Стеки выделяются на каждый файбер; это место можно оптимизировать
(использованные стеки класть в кеш). Сделаем пока просто [stack.h](01-nanofibers-simple/stack.h). 

##### Запуск файбера
Чтоб запустить файбер, нужно настроить контекст. rsp укажем на вершину стека; а rip --- instruction pointer --- на точку входа `Fiber::Trampoline`.
Файбер будет выполнять `std::function<void()>`; функтор стейтфул, поэтому нужно дополнительно
аккуратно пробросить этот стейт; сделаем это через глобальную переменную current_fiber.

##### Шедулер
Поддерживаем очередь (intrusive list) готовых к выполнению файберов.
Все время достаем новый файбер, переключаемся из главного контекста (тот поток, что запустил шедулер)
в поток файбера. `Yield()` переключает нас обратно из контекста файбера в контекст шедулера.
Код получается простой: [scheduler.h](01-nanofibers-simple/scheduler.h)

##### Mutex
Мьютекс и ConditionVariable нельзя использовать стандартные: два вызова `mutex.lock()`
заблокируют целиком поток, а мы хотим явно не этого. Пишем свои: вызов `lock()`, который блокируется,
кладет файбер в специфичную для этого мьютекса очередь ожидания [mutex.h](02-nanofibers-mutex/mutex.h).
