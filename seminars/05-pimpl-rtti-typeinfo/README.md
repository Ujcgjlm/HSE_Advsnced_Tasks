# Семинар 5. Идиома pImpl; vtable, RTTI и их использование

## План

### pImpl

1.1. Напоминание про компиляцию и сборку C++ кода (на лекции было, но стоит напомнить)

* три этапа: препроцессинг, компиляция каждой единицы трансляции, линковка
* библиотеки либо целиком header-only, либо предоставляются открытые header-ы и бинарник для статической (`.a`) или
  динамической (`.so`) линковки
* как мы привыкли делать: декларация класса, описание всех полей и декларация методов в `.h`, реализация - в `.cpp`

1.2. Какие проблемы создает описание класса в header-файле

* перекомпиляция при любом изменении header-ов
* отсутствие обратной совместимости ABI (поменяли что-либо, влияющее на layout в классе - сломали совместимость)
* открытость приватных членов (может хотеться закрыть либо по коммерческим причинам, либо чтобы символы не проникали в
  IDE пользователю)
* большие header-ы транзитивно попадают в каждую единицу трансляции кода пользователя. Увеличивается размер бинарного
  файла и время компиляции

1.3. Реализация pImpl

Будем поэтапно писать pImpl для такого кейса: есть наш интерфейс для `StringSplitter`-а (удобный пользователям), который
под капотом использует boost (см. [pimpl/third-party](pimpl/third-party)) со всеми вытекающими последствиями. Избавимся
от boost-ового хэдера в пользовательских файлах.

| №  | Где лежит код                        | Что происходит                                                                                      |
 | ---|--------------------------------------|-----------------------------------------------------------------------------------------------------|
| 0  | [pimpl/no-pimpl](pimpl/no-pimpl)     | вариант без pimpl, инклюд библиотеки в хедере                                                      |
| 1  | [pimpl/raw-ptr](pimpl/raw-ptr)       | pimpl на сыром указателе                                                                            |
| 2  | [pimpl/unique-ptr](pimpl/unique-ptr) | pimpl на `std::unique_ptr`, в комментариях еще см. про `std::shared_ptr`                            |
| 3  | [pimpl/fast](pimpl/fast)             | fast pimpl (не аллоцируем в куче), валидация `sizeof` и `alignof` в compile-time (см. деструктор)   |

### vtable

2.1. Механизм виртуальных функций

* рассказать, что такое таблица виртуальных функций (хранит указатели на самый дочерний из доступных вариант метода,
  см. [vtable.png](vtable.png))
* реализация полиморфизма не специфирована в стандарте, но все делают через этот механизм

2.2. Показываем пример кода: https://godbolt.org/z/77j7x5P6a. Keypoints:

* на `-O0` видны реализации дефолтных конструкторов. Обратить внимание на то, что указатель на vtable кладется в начало
  класса

* показать, что код самих виртуальных функций `NameYourself()` не отличается от кода невиртуальной
  функции `NonVirtualMethod()`. Отличие в точке вызова `CallNameYourself()` - оно выполняется в три ассемблерные
  инструкции: прочтение указателя на vtable, прочтение адреса метода в таблице и собственно вызов метода

* переключиться на `-O2` и показать, что произошла девиртуализация - в данном случае возможно определить точные типы
  всех переменных во время компиляции и необходимость в рантайм диспетчеризации отпадает. Правда, тут еще и функции
  заинлайнены - но вообще говоря девиртуализация может увеличивать размер бинарника - вместо одного метода, которые "
  принимает решение" в рантайме, делается много "на все случаи жизни".

* показывать виртуальные таблицы при множественном наследовании не очень хочется, углубляться в девиртуализацию - тоже

2.3. `dynamic_cast` ссылок и указателей. Примеры кода в [rtti](rtti).

* стоит проговорить вслух, почему нет `dynamic_cast` по значению

* не всегда требует RTTI, upcasts выполняются в compile-time

* вернуться к примеру на godbolt из прошлого пункта и показать, что в vtable помимо указателей на методы есть
  еще `typeinfo`

2.4. `typeid`, `std::type_info`. Примеры кода в [rtti](rtti).

* тоже не всегда требует RTTI. Для неполиморфных типов эквивалентен `typeid(decltype(expression))`.

* возвращает `const std::type_info&`.

### Обсуждение задач

3.1. `pimpl` - обсудили выше, сама задача простая

3.2. `any` - написали на лекции

3.3. `editor` - ничего сложного, разберутся

3.4. `small-test-framework` - ничего сложного, разберутся

3.5. `scala-vector` - и здесь тоже

### Основные источники

1) https://youtu.be/mkPTreWiglk?t=150 - хорошо про pImpl, fast pImpl
1) https://blog.panicsoftware.com/dynamic_cast-and-typeid-as-non-rtti-tools/ - почти весь код в rtti оттуда