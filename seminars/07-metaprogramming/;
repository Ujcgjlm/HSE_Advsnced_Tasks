<!DOCTYPE html><html><head><meta charset="utf-8"></head><body><textarea id="source">
class: center, middle

# Metaprogramming

---
# Metaprogramming

- Template magic (SFINAE/concepts) (+overloads +stdlib)
- constexpr/consteval (+optimizing compilation)
- Types list, containers (+transparent hashing)
- RTTI (+typeid_cast in ClickHouse)
- Codegen (+ vk.com kPHP)
- Reflection (+boost.pfr)

???
- How to read stdlib and pre C++11 code.
- How to design better APIs by restricting template code usage.
- How not to make your compiler boil.
- How to design containers with help of metaprogramming.
- How to use type information in runtime for better performance.
- How (and why) to generate C++-code.

---
# Template magic

```cpp
template <class Functor, class Container>
auto transform(Functor && functor, Container & container); // C++17

auto transform(auto && functor, auto & container); // C++20, looks like Python

/// Oops, hundreds of lines of messy template messages deep in stdlib
transform([] (std::string) { ... }, vector_of_ints);
```

```cpp
int a;
std::vector<std::vector<int>> v;
std::vector<std::vector<int>>::const_iterator it = std::find( v.begin(), v.end(), a );
```

```cpp
/usr/include/c++/4.6/bits/stl_algo.h: In function ‘_RandomAccessIterator std::__find(_RandomAcce
/usr/include/c++/4.6/bits/stl_algo.h:4403:45:   instantiated from ‘_IIter std::find(_IIter, _IIt
error_code.cpp:8:89:   instantiated from here
/usr/include/c++/4.6/bits/stl_algo.h:162:4: error: no match for ‘operator==’ in ‘__first.__gnu_c
/usr/include/c++/4.6/bits/stl_algo.h:162:4: note: candidates are:
/usr/include/c++/4.6/bits/stl_pair.h:201:5: note: template bool std::operator==(const std::pair&
/usr/include/c++/4.6/bits/stl_iterator.h:285:5: note: template bool std::operator==(const std::r
...
```

???
- Template messages may be misleading
- Production code may be complex
- We need a way to restrict access to our function (better API design)

---
# Template magic

```cpp
template <class T> auto find(std::vector<T>&, const T&);

template <class Ret, class T> // Disallows stateful lambdas
(1) std::vector<Ret> transform(Ret(*functor)(const T&), const std::vector<T> &);

template <class Ret, class T> // Runtime cost
(2) std::vector<Ret> transform(std::function<Ret(const T&)>, const std::vector<T> &);
```

```cpp
template <class T> /// Concepts, C++20
(3) auto transform(std::invocable<T> auto && functor, const std::vector<T> &);

template <class F, class T, typename = std::enable_if_t<std::is_invocable_v<F, T>>>
(4) auto transform(F && functor, const std::vector<T>&); /// SFINAE, C++17
```

???
- We can use various techniques to restrict access, but SFINAE/concepts fit best.

---
# Substitution Failure Is Not An Error

```cpp
template <class It> void process(It begin, It end);

process(vector.begin(), vector.end()); /// Want to differentiate
process(array_begin_ptr, array_begin_ptr + array_size);

// Can obtain nested type: decltype(it)::type
template <class T> struct Iter { using Type = T; T * ptr; };
```

```cpp
template <class Range> void process(Range r);

process(vector); // must have .begin() and .end()
```

???
- Modern C++ allows us to write less code (e.g. range in comparison with passing explicit begin and end).
- We can perform various optimizations depending on passed types

---
# `std::enable_if[_t]`

```cpp
template <bool Cond, class T = void>
struct enable_if {};

template <class T> // Partial specialization
struct enable_if<true, T>{ using Type = T; };

template <bool Cond, class T>
using enable_if_t = typename enable_if<Cond, T>::Type;
```

```cpp
template <class F, class T, typename = std::enable_if_t<std::is_invocable_v<F, T>>>
auto transform(F && functor, const std::vector<T>&); /// SFINAE, C++17

/// typename = std::enable_if_t<true> = void
transform([](int) {}, vector_of_ints);

/// typename = std::enable_if_t<false>. No type in enable_if_t,
/// overload is banned ("ill-formed")
transform([](std::string) {}, vector_of_ints);
```

???
- Basically, a function specialization. Trying to get a type from an empty structure
  either yields a compile error or makes the overload ill-formed

---
# `std::is_invocable[_v]`

```cpp
template <class F, class T>
struct is_invocable { constexpr bool value = false; };

template <class F, class T> /// Appeared in C++11
struct is_invocable< /*some spec */> { constexpr bool value = true; };

template <class F, class T> /// Appeared in C++14
constexpr bool is_invocable_v = is_invocable<F, T>::value;
```

```cpp
template <class F, class T, typename = std::enable_if_t<std::is_invocable_v<F, T>>>
auto transform(F && functor, const std::vector<T>&); /// SFINAE, C++17
```

---
# Conditional overloads (dispatching)

```cpp

template <typename Integer, typename = std::enable_if_t<std::is_integral<Integer>::value>>
void foo(Integer);

template <typename Floating,
    typename = std::enable_if_t<std::is_floating_point<Floating>::value>>
void foo(Floating); // error: redefinition
```

```cpp
 
template <typename Integer, std::enable_if_t<std::is_integral<Integer>::value, bool> = true>
void foo(Integer);
 
template <typename Floating,
    std::enable_if_t<std::is_floating_point<Floating>::value, bool> = true>
void foo(Floating);
```

> Default template arguments are not accounted for in function template equivalence
https://en.cppreference.com/w/cpp/language/function_template#Function_template_overloading

???
- In pre C++11 (compilers without if constexpr) we can have multiple restricted overloads, but
  their implementation is ugly.

---
# Conditional overloads (modern)

```cpp
template <class T>
void foo(T) {
    if constexpr(std::is_same_v<T, int>)
      ///
    if constexpr(std::is_same_v<T, Iter>)
      /// can use typename Iter::Type as only
      /// one branch gets evaluated
    else
        static_assert(false);
}
```

???
- Tell that an ordinary if needs to evaluate all branches.

---
# `find(Range)`

```cpp
template <class Range> void process(Range r);

process(vector); // must have .begin() and .end()
```

```cpp
template <class T, typename = void>
struct is_iterable : std::false_type {};

template <class T>
struct is_iterable<T, std::void_t<decltype(std::declval<T>().begin()),
                                  decltype(std::declval<T>().end())>>
    : std::true_type {};
```

---
# `decltype(), declval<T>()`

```cpp
int a; static_assert(std::is_same_v<int, decltype(a)>);

auto a = get_const_int(); // a = int
auto a = get_const_volatile_lvalue_int(); // a = int

// decltype(get_const_int()) == const int

decltype(auto) a = get_const_int(); // a = const int
decltype(auto) a = get_const_volatile_lvalue_int(); // a = const volatile int &
```

```cpp
// For use in unevaluated contexts. Real implementation is more complicated
template <class T> auto declval() -> T&&;

struct Default { int foo() const; };
struct NonDefault { NonDefault() = delete; int foo() const; };
 
decltype(Default().foo()) n1 = 1;
//decltype(NonDefault().foo()) n2 = n1; // error: no default constructor
decltype(declval<NonDefault>().foo()) n2 = n1;
```

???
- Decltype -- obtain a type. Two ways of getting the type -- auto (does not preserve qualifiers)
  and decltype(auto).
- Declval -- operate on T in unevaluated contexts when T may not be default constructible.

---
# `decltype(auto) + lambdas`

```cpp
// not returning reference if needed, extra copy
transform(first, last, []<class T>(T&& x) {
    return foo(std::forward<T>(x));
});

transform(first, last, []<class T>(T&& x) -> decltype(auto) {
    return foo(std::forward<T>(x));
});

// invocation for overloadable functions
invoke([](auto&& x) -> decltype(test(std::forward<decltype(x)>(x)))
{
	return test(std::forward<decltype(x)>(x));
});
```

http://open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0573r0.html

???
- decltype(auto) used in lambdas return types to avoid a copy. Hard to write optimal code, see proposal

---
# `std::is_nothrow_move_constructible`

---
# `std::is_nothrow_move_constructible` (solution)

```cpp
template <class T, class ...Args>
static constexpr bool nothrow_cons =
    noexcept(T(declval<Args>()...));

template<class T>
static constexpr bool nothrow_move_cons =
    nothrow_cons<T, std::add_rvalue_reference_t<T>>;
```

---
# `std::void_t`

```cpp
template<class, class = void> struct has_member_foo
  : std::false_type { };

template<class T>
struct has_member_foo<T, std::void_t<decltype( std::declval<T&>().foo() )>>
  : std::true_type { };

template <class ...> using void_t = void;
```

---
# `find(Range)` with concepts

```cpp
template <class Range> void process(Range r);

process(vector); // must have .begin() and .end()
```

```cpp
template <class T, typename = void>
struct is_iterable : std::false_type {};

template <class T>
struct is_iterable<T, std::void_t<decltype(std::declval<T>().begin()),
                                  decltype(std::declval<T>().end())>>
    : std::true_type {};
```

```cpp
template <class T>
concept is_iterable = requires (const T& a) {
  std::begin(a);
  std::end(a);
};
```

https://en.cppreference.com/w/cpp/ranges/range

---
# `std::is_polymorphic`

```cpp
template <class T>
std::true_type detect_is_polymorphic(
    /// A polymorphic type must support dynamic_cast
    decltype(dynamic_cast<const volatile void*>(static_cast<T*>(nullptr)))
);

/// Ellipsis overload has lowest priority
template <class T> std::false_type detect_is_polymorphic(...);
 
template <class T>
using is_polymorphic_v = decltype(detect_is_polymorphic<T>(nullptr));
```

- Not portable among architectures
- Not portable among compilers (MSVC)

---
# `std::is_union` and co.

> Anything you can do with a class, you can do with a union

```cpp
// libc++
template <class _Tp> /* */ is_union
    : public __libcpp_union<typename remove_cv<_Tp>::type> {};

TYPE_TRAIT_1(__is_union, IsUnion, KEYCXX) // AST/Decl.h

bool isUnion () const { return getTagKind() == TTK_Union; } //AST/APValue.h
```

https://github.com/Quuxplusone/from-scratch/blob/master/include/scratch/bits/type-traits/compiler-magic.md

---
# `if consteval`

```cpp
constexpr double power(double b, int x)
{
    if (std::is_constant_evaluated()) { /// NOT if constexpr
        // constexpr-friendly (probably, more simple) algo that 
        // does not make your compiler boil.
    } else {
        // Runtime version
    }
}
```

```cpp
constexpr bool is_constant_evaluated() noexcept
{
    if consteval { // syntactic sugar, braces required
        return true;
    }
    else {
        return false;
    }
}
```

???
- Way to write optimal code by providing two separate implementations


---
# Type list

```cpp
type_list<type1, type2>; TYPE_LIST5(T, TYPE_LIST4); // Pre C++-11, Alexandrescu-like (Loki)
type_list<type1, type2, ...>; // C++11, variadic templates

template <class ...> struct type_list {};
```

```cpp
template <size_t I, class T, class ...Other>
struct get {
    static_assert(I <= sizeof...(Other));

    using Type = std::conditional_t<(I == 0),
      T,
      typename get<I - 1, Other...>::Type>;
};
```

---
# Transparent hashing

A.k.a. heterogeneous lookup for unordered containers

---
# Transparent hashing (solution)

---
# Transparent hashing (solution)

---
# Lambdas in unevaluated contexts

Not supported by gcc + clang

---
# RTTI

typeid() and typeid_cast in CH

---
# Codegen

vk.com kPHP -- transpiling PHP into C++

https://habr.com/ru/company/vk/blog/527420

Legacy -> speed

---
# Reflection

</textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script> var s = remark.create({ ratio: '16:9', highlightLines: true, highlightStyle: "tomorrow-night"}); </script></body></html>
