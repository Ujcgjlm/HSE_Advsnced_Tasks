# Сборка, зависимости, экосистема

## Системы сборки

Написать код -- полдела (или даже меньше). 
Дальше нужно фиксить баги, читать чужой код, ещё фиксить баги, добавлять фичи,
убирать фичи, конфигурировать фичи, и ещё кучу всего!

>Отлично, с кодом закончили! 
Теперь можно проверить, всё ли у нас хорошо.
Нужно лишь всё собрать и запустить.
Oh, wait...

К сожалению, хранить весь код в одном файле очень тяжело для восприятия,
конфликтно для системы версионирования и плохо для времени компиляции.

### Make

Вещи, придуманные в 80-90-х годах, до сих пор работают и иногда делают
это достаточно эффективно.

### Ninja

Make -- это, конечно, хорошо, но можно ли по-быстрее?
Можно:

![](https://www.incredibuild.com/wp-content/uploads/2021/04/Ninja_top-open-source-build-tools.jpg)

Ninja точно так же позволяет собирать проекты (небольшие можно вручную,
большие вручную не выйдет: подробнее дальше), причём эта система 
сборки делает основной упор на скорость.
Но ещё одна особенность Ninja -- адаптивность под более высокоуровневые системы
сборки; то есть Ninja выступает своего рода ассемблером для других 
систем сборки.

### CMake

CMake -- де-факто стандартная система сборки C++
(исключение -- крупные компании, у которых есть ресурсы на разработку
и поддержку самописных систем сборки).

### Meson

Meson -- альтернатива CMake со статической типизацией, но без возможности
писать собственные функции.

### Bazel

Bazel -- система сборки от Google (so, _opinionated_).

## Пакетные менеджеры

> Так, мы наконец-то всё собрали, и оно вроде бы даже работает.
Теперь нам нужно автоматическое тестирование! Oh... Fuck, not again...

Писать всё с нуля (например, библиотеку для тестирования) можно, 
но не всегда нужно/хочется/есть на это время или силы или деньги.
В таких случаях можно воспользоваться чужими библиотеками/фреймворками, 
которых в open source огромное количество (или наработки другой команды внутри 
вашей общей кодовой базы; или проприетарный софт, если не повезло).

Однако, подключить внешнюю зависимость в C++ проект не так просто, 
как, например, в Python / JavaScript / Rust / Go / ... -- для этих языков 
существуют пакетные менеджеры 
[pip](https://pypi.org/project/pip/) 
/ [npm](https://www.npmjs.com/)
/ [cargo](https://doc.rust-lang.org/cargo/)
/ [go modules](https://go.dev/blog/using-go-modules) / ..., 
позволяющие одной командой подтянуть необходимую версию стороннего пакета.

### Conan

Conan -- попытка сообщества соорудить свой собственный пакетный менеджер.

### vcpkg

vcpkg -- пакетный менеджер от Microsoft.

### build2

build2 -- потенциальный cargo для C++.

## Примеры проектов

### [Плохо](./project-examples/bad)

#### Плюсы

* Работает (возможно)

#### Минусы

* Как собрать?
* Хотя бы краткое описание?

### [Нормально](./project-examples/okay)

#### Плюсы

Всё, что выше, а также:

#### Минусы

* `#pragma once` спасёт в большинстве случаев, но не во всех
* Торчат зависимости, которые можно было бы спрятать

### [Хорошо](./project-examples/good)

#### Плюсы

Всё, что выше, а также:

* Наличие тестов
* Полноценный `readme.md`
* Наличие конфигов `.clang-format` и `.clang-tidy` позволяет автоматически
  проверять соответствие кодстайлу в CI пайплайнах

#### Минусы

* Единственный вариант подключения этой библиотеки -- через CMake

### [Отлично](./project-examples/great)
