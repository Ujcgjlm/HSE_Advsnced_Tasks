# Сборка, зависимости, экосистема

## Системы сборки

Написать код -- полдела (или даже меньше). 
Дальше нужно фиксить баги, читать чужой код, ещё фиксить баги, добавлять фичи,
убирать фичи, конфигурировать фичи, и ещё кучу всего!

>Отлично, с кодом закончили! 
Теперь можно проверить, всё ли у нас хорошо.
Нужно лишь всё собрать и запустить.
Oh, wait...

К сожалению, хранить весь код в одном файле очень тяжело для восприятия,
конфликтно для системы версионирования и плохо для времени компиляции.
Поэтому разработчики стараются разбивать код на файлы, что ведёт к другой
сложности -- как собрать эту кучу файлов вместе и скомпилировать?

Можно, конечно, сделать один большой bash скрипт, в котором будут перечислены
все файлы и одна большая команда для таргетного компилятора:

```shell
clang++ \
  -std=c++42 \
  -Wall -Werror -Wextra -Wpedantic -Whowmanyflagsdoihavetoputhere \
  -o main \
  search.cpp logger.cpp allocator.cpp main.cpp
```

Однако такой подход вынуждает компилировать все файлы заново на каждый чих.
Чтобы такого избежать, нужно кэшировать результаты компиляции 
(_артефакты_) отдельных TU (translation units) и компилировать их заново только 
в случае, если изменились исходники.

Более того, собирать проект хочется с разными опциями:

* В продакшен мы катим (чаще всего) релизную сборку.
* Тестим в дебажной и в релизной с санитайзерами.
* Иногда нужна релизная сборка с дебажными символами.

Обрабатывать все эти вариации в нашем несчастном bash скрипте -- дело тяжёлое
и неблагодарное.

Помимо всего этого, в крупных компаниях существует распределённая сборка --
одновременная компиляция разных TU на разных машинах, чтобы ускорить процесс
сборки для огромных проектов.

Видно, что проблема довольно насущная и её решение напрямую влияет на
разработчиков (например, сколько времени они тратят впустую, пока ждут
компиляцию очередного шаблона) и качество продакшена.

Решением тут выступают системы сборки -- специализированный софт, который
собирает другой софт. 
В нашем курсе, например, используется CMake (про него мы ещё чуть позже
поговорим).

### Make

Вещи, придуманные в 80-90-х годах, до сих пор работают и иногда делают
это достаточно эффективно: точно также обстоят дела с системой Make.

Для того чтобы начать сборку, Make ищет файл Makefile, в котором описаны
основные таргеты и их зависимости. 
Сами Makefile-ы напоминают последовательность команд (почти как bash скрипты),
однако Make умеет понимать, когда артефакты are up-to-date и не требуют 
повторной сборки.

Для маленьких и небольших проектов Make вполне может хватить,
но стоит понимать, что использование Make перекладывает на вас ответственность
за кросс-платформенность сборки (потому что последовательность shell команд
зависит от используемого shell'а -- POSIX команды bash'а могут не работать
на Windows).

[Примеры сборки доступны тут.](./build-systems/make)

### Ninja

Make -- это, конечно, хорошо, но можно ли побыстрее?
Можно:

![ninja-vs-make](https://www.incredibuild.com/wp-content/uploads/2021/04/Ninja_top-open-source-build-tools.jpg)

Ninja точно так же позволяет собирать проекты (небольшие можно вручную,
большие вручную не выйдет: подробнее дальше), причём эта система 
сборки делает основной упор на скорость.
Но ещё одна особенность Ninja -- адаптивность под более высокоуровневые системы
сборки; то есть Ninja выступает своего рода ассемблером для других 
систем сборки.

### CMake

CMake -- де-факто стандартная система сборки C++
(исключение -- крупные компании, у которых есть ресурсы на разработку
и поддержку самописных систем сборки).

### Meson

Meson -- альтернатива CMake со статической типизацией, но без возможности
писать собственные функции.

### Bazel

Bazel -- система сборки от Google (so, _opinionated_).

## Пакетные менеджеры

> Так, мы наконец-то всё собрали, и оно вроде бы даже работает.
Теперь нам нужно автоматическое тестирование! Oh... Fuck, not again...

Писать всё с нуля (например, библиотеку для тестирования) можно, 
но не всегда нужно/хочется/есть на это время или силы или деньги.
В таких случаях можно воспользоваться чужими библиотеками/фреймворками, 
которых в open source огромное количество (или наработки другой команды внутри 
вашей общей кодовой базы; или проприетарный софт, если не повезло).

Однако, подключить внешнюю зависимость в C++ проект не так просто, 
как, например, в Python / JavaScript / Rust / Go / ... -- для этих языков 
существуют пакетные менеджеры 
[pip](https://pypi.org/project/pip/) 
/ [npm](https://www.npmjs.com/)
/ [cargo](https://doc.rust-lang.org/cargo/)
/ [go modules](https://go.dev/blog/using-go-modules) / ..., 
позволяющие одной командой подтянуть необходимую версию стороннего пакета.

### Conan

Conan -- попытка сообщества соорудить свой собственный пакетный менеджер.

### vcpkg

vcpkg -- пакетный менеджер от Microsoft.

### build2

build2 -- потенциальный cargo для C++. 
На первый взгляд, сборка выглядят довольно непривычно:
```build2
cxx.std = latest

using cxx

hxx{*}: extension = hxx
ixx{*}: extension = ixx
txx{*}: extension = txx
cxx{*}: extension = cxx

if ($cxx.target.system == 'win32-msvc')
  cxx.poptions += -D_CRT_SECURE_NO_WARNINGS -D_SCL_SECURE_NO_WARNINGS

if ($cxx.class == 'msvc')
  cxx.coptions += /wd4251 /wd4275 /wd4800

# The test target for cross-testing (running tests under Wine, etc).
#
test.target = $cxx.target
```

## Примеры проектов

### [Плохо](./project-examples/bad)

#### Плюсы

* Работает (возможно)

#### Минусы

* Как собрать?
* Хотя бы краткое описание?

### [Нормально](./project-examples/okay)

#### Плюсы

Всё, что выше, а также:

#### Минусы

* `#pragma once` спасёт в большинстве случаев, но не во всех
* Торчат зависимости, которые можно было бы спрятать

### [Хорошо](./project-examples/good)

#### Плюсы

Всё, что выше, а также:

* Наличие тестов
* Полноценный `readme.md`
* Наличие конфигов `.clang-format` и `.clang-tidy` позволяет автоматически
  проверять соответствие кодстайлу в CI пайплайнах

#### Минусы

* Единственный вариант подключения этой библиотеки -- через CMake

### [Отлично](./project-examples/great)
